package com.commercetools.project.sync.customobject;

import static com.commercetools.project.sync.util.SyncUtils.IDENTIFIER_NOT_PRESENT;
import static com.commercetools.project.sync.util.SyncUtils.logErrorCallback;
import static com.commercetools.project.sync.util.SyncUtils.logWarningCallback;

import com.commercetools.api.client.ByProjectKeyCustomObjectsGet;
import com.commercetools.api.client.ProjectApiRoot;
import com.commercetools.api.models.custom_object.CustomObject;
import com.commercetools.api.models.custom_object.CustomObjectDraft;
import com.commercetools.api.models.custom_object.CustomObjectDraftBuilder;
import com.commercetools.api.models.custom_object.CustomObjectPagedQueryResponse;
import com.commercetools.project.sync.SyncModuleOption;
import com.commercetools.project.sync.Syncer;
import com.commercetools.project.sync.service.CustomObjectService;
import com.commercetools.project.sync.service.impl.CustomObjectServiceImpl;
import com.commercetools.project.sync.util.SyncUtils;
import com.commercetools.sync.commons.exceptions.SyncException;
import com.commercetools.sync.commons.utils.QuadConsumer;
import com.commercetools.sync.commons.utils.TriConsumer;
import com.commercetools.sync.customobjects.CustomObjectSync;
import com.commercetools.sync.customobjects.CustomObjectSyncOptions;
import com.commercetools.sync.customobjects.CustomObjectSyncOptionsBuilder;
import com.commercetools.sync.customobjects.helpers.CustomObjectCompositeIdentifier;
import com.commercetools.sync.customobjects.helpers.CustomObjectSyncStatistics;
import com.commercetools.sync.customobjects.models.NoopResourceUpdateAction;
import java.time.Clock;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// This class compiles but not tested yet
// TODO: Test class and adjust logic if needed
public final class CustomObjectSyncer
    extends Syncer<
        CustomObject,
        NoopResourceUpdateAction,
        CustomObjectDraft,
        CustomObjectSyncStatistics,
        CustomObjectSyncOptions,
        ByProjectKeyCustomObjectsGet,
        CustomObjectPagedQueryResponse,
        CustomObjectSync> {

  private static final Logger LOGGER = LoggerFactory.getLogger(CustomObjectSyncer.class);
  private final String runnerName;
  private final boolean isSyncProjectSyncCustomObjects;

  /**
   * Instantiates a {@link Syncer} which is used to sync resources from a source to a target
   * commercetools project.
   *
   * @param sync The sync module that is used for syncing the resource drafts to the target project,
   *     after being transformed from the resources fetched from the source project.
   * @param sourceClient the client used for querying data from the source commercetools project.
   * @param targetClient the client used for syncing the transformed drafts into the target
   *     commercetools project.
   * @param customObjectService service that is used for fetching and persisting the last sync
   *     timestamp for delta syncing.
   * @param clock the clock to record the time for calculating the sync duration.
   * @param isSyncProjectSyncCustomObjects if true, custom objects generated by the project sync
   *     will not be excluded.
   * @param runnerName name for the running sync instance. It is passed as a CLI param from user. It
   *     is used here to generate names of custom objects created by this application so we can
   *     exclude/include those custom objects as requested.
   */
  private CustomObjectSyncer(
      @Nonnull CustomObjectSync sync,
      @Nonnull ProjectApiRoot sourceClient,
      @Nonnull ProjectApiRoot targetClient,
      @Nonnull CustomObjectService customObjectService,
      @Nonnull Clock clock,
      @Nullable String runnerName,
      boolean isSyncProjectSyncCustomObjects) {
    super(sync, sourceClient, targetClient, customObjectService, clock);
    this.runnerName = runnerName;
    this.isSyncProjectSyncCustomObjects = isSyncProjectSyncCustomObjects;
  }

  @Nonnull
  @Override
  protected CompletableFuture<List<CustomObjectDraft>> transform(@Nonnull List<CustomObject> page) {
    final List<CustomObjectDraft> collect =
        page.stream()
            .map(
                customObject ->
                    CustomObjectDraftBuilder.of()
                        .container(customObject.getContainer())
                        .key(customObject.getKey())
                        .value(customObject.getValue())
                        .build())
            .collect(Collectors.toList());
    return CompletableFuture.completedFuture(collect);
  }

  @Nonnull
  @Override
  protected ByProjectKeyCustomObjectsGet getQuery() {
    final ByProjectKeyCustomObjectsGet customObjectQuery = getSourceClient().customObjects().get();
    if (isSyncProjectSyncCustomObjects) {
      return customObjectQuery;
    } else {
      final List<String> excludedContainerNames = getExcludedContainerNames();
      final String asStringList = excludedContainerNames.stream().collect(Collectors.joining(","));
      return customObjectQuery
          .withWhere("container not in (:excludedNames)")
          .withPredicateVar("excludedNames", asStringList);
    }
  }

  @Nonnull
  @Override
  protected Logger getLoggerInstance() {
    return LOGGER;
  }

  @Nonnull
  public static CustomObjectSyncer of(
      @Nonnull final ProjectApiRoot sourceClient,
      @Nonnull final ProjectApiRoot targetClient,
      @Nonnull final Clock clock,
      @Nullable final String runnerName,
      final boolean isSyncProjectSyncCustomObjects) {
    final QuadConsumer<
            SyncException,
            Optional<CustomObjectDraft>,
            Optional<CustomObject>,
            List<NoopResourceUpdateAction>>
        logErrorCallback =
            (exception, newResourceDraft, oldResource, updateActions) -> {
              final String resourceIdentifier = getCustomObjectResourceIdentifier(oldResource);
              updateActions = updateActions == null ? Collections.emptyList() : updateActions;
              logErrorCallback(
                  LOGGER, "customObject", exception, resourceIdentifier, updateActions);
            };
    final TriConsumer<SyncException, Optional<CustomObjectDraft>, Optional<CustomObject>>
        logWarningCallback =
            (exception, newResourceDraft, oldResource) -> {
              final String resourceIdentifier = getCustomObjectResourceIdentifier(oldResource);
              logWarningCallback(LOGGER, "customObject", exception, resourceIdentifier);
            };
    final CustomObjectSyncOptions syncOptions =
        CustomObjectSyncOptionsBuilder.of(targetClient)
            .errorCallback(logErrorCallback)
            .warningCallback(logWarningCallback)
            .build();

    final CustomObjectSync customObjectSyncer = new CustomObjectSync(syncOptions);

    final CustomObjectService customObjectService = new CustomObjectServiceImpl(targetClient);

    return new CustomObjectSyncer(
        customObjectSyncer,
        sourceClient,
        targetClient,
        customObjectService,
        clock,
        runnerName,
        isSyncProjectSyncCustomObjects);
  }

  private static String getCustomObjectResourceIdentifier(
      @Nonnull Optional<CustomObject> oldResource) {
    return oldResource
        .map(CustomObjectCompositeIdentifier::of)
        .map(CustomObjectCompositeIdentifier::toString)
        .orElse(IDENTIFIER_NOT_PRESENT);
  }

  /**
   * This method build container names of all custom objects generated by the project-sync. They're
   * not included in the fetch query for custom objects and thus will not be synced to the target
   * projects.
   */
  private List<String> getExcludedContainerNames() {
    final List<String> lastSyncTimestampContainerNames =
        Stream.of(SyncModuleOption.values())
            .map(
                syncModuleOption -> {
                  final String moduleName = syncModuleOption.getSyncModuleName();
                  return SyncUtils.buildLastSyncTimestampContainerName(moduleName, this.runnerName);
                })
            .collect(Collectors.toList());
    final List<String> currentCtpTimestampContainerNames =
        Stream.of(SyncModuleOption.values())
            .map(
                syncModuleOption -> {
                  final String moduleName = syncModuleOption.getSyncModuleName();
                  return SyncUtils.buildCurrentCtpTimestampContainerName(
                      moduleName, this.runnerName);
                })
            .collect(Collectors.toList());
    final List<String> excludedContainerNames =
        Stream.concat(
                lastSyncTimestampContainerNames.stream(),
                currentCtpTimestampContainerNames.stream())
            .collect(Collectors.toList());
    return excludedContainerNames;
  }
}
